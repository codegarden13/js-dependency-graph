// public/assets/js/d3_codeStructure.js
/**
 * D3 Code Structure Graph (v7)
 * ===========================
 *
 * Purpose
 * -------
 * Renders a dependency graph (files/modules) for NodeAnalyzer metrics output.
 * This script is UI-only and consumes a JSON payload generated by the backend.
 *
 * Frontend Module Dependencies (globals)
 * --------------------------------------
 * - window.CodeGraphData.normalize(metrics) -> { nodes, links }
 * - window.CodeGraphInteractions.attachNodeInteractions(nodeSel, opts)
 * - window.CodeGraphHulls.renderTypeHulls(hullGroup, nodes, clusterColorScale)
 * - window.CodeGraphUI.setupGraphFilters(...)
 * - window.CodeGraphUI.buildGraphLegend(...)
 * - window.CodeGraphUI.buildGraphDiagnosticsPanel(...)
 * - window.CodeGraphUI.escapeHtml(...)
 *
 * Integration Hooks
 * -----------------
 * - window.onGraphNodeSelected(node): optional async hook on node click
 * - window.NAV_REDIRECT_ON_CLICK === true: enables legacy redirects on click
 * - window.initHighlightId: if set, highlights a node after render
 */

(function () {
  "use strict";

  /* ======================================================================
     Configuration (Colors)
  ====================================================================== */

  const NODE_TYPE_COLORS = {
    controller: "#ff6b6b",
    service: "#4d96ff",
    module: "#ff9933",
    repository: "#ffd166",
    config: "#f72585",
    core: "#4361ee",
    helper: "#9d4edd",
    file: "#adb5bd"
  };

  const LINK_TYPE_COLORS = {
    include: "#FF6B6B",
    use: "#4D96FF",
    extends: "#06D6A0",
    call: "#8338EC",
    default: "#BBBBBB"
  };

  const clusterColor = d3.scaleOrdinal(d3.schemeSet3);

  /* ======================================================================
     Color Utilities
  ====================================================================== */

  function hexToRgb(hex) {
    hex = String(hex || "").replace("#", "");
    if (hex.length === 3) hex = hex.split("").map((c) => c + c).join("");
    const num = parseInt(hex, 16);
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }

  function rgbToHex(r, g, b) {
    const toHex = (v) => {
      const s = Math.max(0, Math.min(255, Math.round(v))).toString(16);
      return s.length === 1 ? "0" + s : s;
    };
    return "#" + toHex(r) + toHex(g) + toHex(b);
  }

  /**
   * Adjust color intensity by mixing toward white (factor < 1) or black (factor > 1).
   * factor is clamped to avoid extreme outputs.
   */
  function adjustColorIntensity(baseHex, factor) {
    const { r, g, b } = hexToRgb(baseHex);
    const k = Math.max(0, Math.min(1.3, factor));
    const mixTo = k < 1 ? 255 : 0;
    const t = k < 1 ? (1 - k) : (k - 1);
    return rgbToHex(
      r * (1 - t) + mixTo * t,
      g * (1 - t) + mixTo * t,
      b * (1 - t) + mixTo * t
    );
  }

  /* ======================================================================
     Public Entrypoint
  ====================================================================== */

  window.initcodeStructureChart = function initcodeStructureChart(svgId, metrics) {
    // 0) Validate external helpers early (fail loudly in dev)
    assertGlobals();

    // 1) Select + reset SVG (critical for re-runs)
    const svg = d3.select("#" + svgId);
    if (svg.empty()) {
      console.warn("SVG not found:", svgId);
      return;
    }
    svg.selectAll("*").remove();

    const width = 1200;
    const height = 800;

    svg
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    // 2) Layers (back → front)
    // IMPORTANT: highlight is between node shapes and node labels (prevents ring-over-text)
    const zoomLayer = svg.append("g");
    const hullGroup = zoomLayer.append("g").attr("class", "hulls");
    const linkGroup = zoomLayer.append("g").attr("class", "links");
    const nodeShapeGroup = zoomLayer.append("g").attr("class", "node-shapes");
    const highlightLayer = zoomLayer.append("g").attr("class", "highlight-layer");
    const nodeLabelGroup = zoomLayer.append("g").attr("class", "node-labels");

    // 3) Tooltip (singleton)
    const tooltip = ensureTooltip();

    // 4) Zoom + pan
    svg.call(
      d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", (event) => zoomLayer.attr("transform", event.transform))
    );

    // 5) Arrow marker
    defineArrowMarker(svg);

    // 6) Normalize incoming metrics (delegated)
    const { nodes, links } = window.CodeGraphData.normalize(metrics);

    // 7) Visual encodings
    const getNodeColor = (d) => {
      const base = NODE_TYPE_COLORS[d.type] || NODE_TYPE_COLORS.file;
      const c = d._complexityScore ?? 0;
      const intensity = 0.25 + 0.75 * c;
      return adjustColorIntensity(base, intensity);
    };

    const getRadius = (d) => {
      const s = d._lineScore ?? 0;
      const minR = 6;
      const maxR = 26;
      return minR + (maxR - minR) * s;
    };

    // 8) Force simulation
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id((d) => d.id).distance(80).strength(0.35))
      .force("charge", d3.forceManyBody().strength(-140))
      .force("collide", d3.forceCollide().radius((d) => getRadius(d) + 4).iterations(2))
      .force("x", d3.forceX(width / 2).strength(0.03))
      .force("y", d3.forceY(height / 2).strength(0.03))
      .force("center", d3.forceCenter(width / 2, height / 2));

    // 9) Render links
    const linkSel = linkGroup.selectAll("line")
      .data(links)
      .enter()
      .append("line")
      .attr("class", "link")
      .attr("stroke", (d) => LINK_TYPE_COLORS[d.type] || LINK_TYPE_COLORS.default)
      .attr("stroke-width", 1.5)
      .attr("stroke-opacity", 0.8)
      .attr("marker-end", "url(#arrowhead)");

    // 10) Render node shapes (g -> visible circle + invisible hit circle)
    // Interactions attach to the nodeShapeSel (so labels are never part of hit-testing)
    const nodeShapeSel = nodeShapeGroup.selectAll("g")
      .data(nodes)
      .enter()
      .append("g")
      .attr("class", "node");

    // Visible node body
    nodeShapeSel.append("circle")
      .attr("class", "node-body")
      .attr("r", (d) => getRadius(d))
      .attr("fill", (d) => getNodeColor(d));

    // Transparent hit area (slightly larger, easier click/drag)
    nodeShapeSel.append("circle")
      .attr("class", "node-hit")
      .attr("r", (d) => getRadius(d) + 8)
      .attr("fill", "transparent")
      .attr("stroke", "transparent")
      .style("cursor", "pointer")
      .on("mouseover", (event, d) => showTooltip(tooltip, event, d))
      .on("mouseout", () => hideTooltip(tooltip));

    // 11) Render labels in their own layer (ALWAYS above highlight ring)
    const labelSel = nodeLabelGroup.selectAll("text")
      .data(nodes)
      .enter()
      .append("text")
      .attr("class", "node-label")
      .attr("x", (d) => -getRadius(d) - 6)
      .attr("y", 4)
      .style("font-size", "11px")
      .style("font-family", "sans-serif")
      .style("pointer-events", "none")
      .style("fill", "#444")
      .text((d) => (d.id || "").split("/").pop());

    // 12) Interactions (drag + click suppression + selection hook)
    window.CodeGraphInteractions.attachNodeInteractions(nodeShapeSel, {
      simulation,
      thresholdPx: 5,
      onSelected: async (node) => {
        // 1) New behavior: render README + info panel
        if (typeof window.onGraphNodeSelected === "function") {
          await window.onGraphNodeSelected(node);
        }

        // 2) Optional legacy redirect
        if (window.NAV_REDIRECT_ON_CLICK === true) {
          handleNodeClick(node);
        }

        // 3) Always highlight the selected node (local feedback)
        drawHighlight(node, highlightLayer);
      },
      enableLegacyRedirect: false,
      legacyRedirect: null
    });

    // 13) Tick loop: positions + hulls + highlight anchoring
    simulation.on("tick", () => {
      linkSel
        .attr("x1", (d) => d.source.x)
        .attr("y1", (d) => d.source.y)
        .attr("x2", (d) => d.target.x)
        .attr("y2", (d) => d.target.y);

      nodeShapeSel.attr("transform", (d) => `translate(${d.x},${d.y})`);
      labelSel.attr("transform", (d) => `translate(${d.x},${d.y})`);

      anchorHighlight(highlightLayer);

      window.CodeGraphHulls.renderTypeHulls(hullGroup, nodes, clusterColor);
    });

    // 14) Simulation end → diagnostics panel
    simulation.on("end", () => {
      window.CodeGraphUI.buildGraphDiagnosticsPanel(svgId, nodes, links, width, height);
    });

    // 15) Restore highlight (optional)
    if (window.initHighlightId) {
      const match = nodes.find((n) => n.id === window.initHighlightId);
      if (match) drawHighlight(match, highlightLayer);
    }

    // 16) Optional UI integrations: filters + legend
    // NOTE: filters work on nodeShapeSel (the interactive selection)
    window.CodeGraphUI.setupGraphFilters(svgId, metrics, nodeShapeSel, linkSel);
    window.CodeGraphUI.buildGraphLegend(svgId, nodes, links, NODE_TYPE_COLORS, LINK_TYPE_COLORS, clusterColor);

    // 17) Expose state for debugging / external helpers
    svg.node().__graphState = { nodes, links, highlightLayer };
    window.lastGraphState = { nodes, links, simulation };
    console.info("Graph state available at window.lastGraphState");

    return { svg, nodes, links, simulation };
  };

  /* ======================================================================
     Public Helper: Highlight node by ID
  ====================================================================== */

  window.highlightGraphNode = function highlightGraphNode(svgId, nodeId) {
    const svg = d3.select("#" + svgId);
    if (svg.empty()) return;

    const state = svg.node().__graphState;
    if (!state) return;

    const { nodes, highlightLayer } = state;
    const d = nodes.find((n) => n.id === nodeId);
    if (!d) return;

    drawHighlight(d, highlightLayer);
  };

  /* ======================================================================
     Tooltip helpers
  ====================================================================== */

  function ensureTooltip() {
    let t = d3.select("body").select("div.tooltip");
    if (t.empty()) {
      t = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("background", "#333")
        .style("color", "#fff")
        .style("padding", "8px 12px")
        .style("border-radius", "6px")
        .style("pointer-events", "none")
        .style("opacity", 0);
    } else {
      t.style("opacity", 0);
    }
    return t;
  }

  function showTooltip(tip, event, d) {
    const esc = window.CodeGraphUI.escapeHtml;

    const lines =
      d.__displayLines ??
      d.lines ??
      d.loc ??
      d.size ??
      "?";

    const cx =
      d.__displayComplexity ??
      d.complexity ??
      d.cc ??
      ((d._inbound || 0) + (d._outbound || 0)) ??
      "?";

    tip.transition().duration(150).style("opacity", 0.95);

    tip
      .html(
        `<strong>${esc(d.id)}</strong>` +
        `<br><small>Type: ${esc(d.type || "file")}</small>` +
        `<br><small>Lines: ${esc(lines)}</small>` +
        `<br><small>Complexity: ${esc(cx)}</small>`
      )
      .style("left", (event.pageX + 15) + "px")
      .style("top", (event.pageY - 28) + "px");
  }

  function hideTooltip(tip) {
    tip.transition().duration(150).style("opacity", 0);
  }

  /* ======================================================================
     Marker / defs
  ====================================================================== */

  function defineArrowMarker(svg) {
    svg.append("defs")
      .append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 23)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#999")
      .style("stroke", "none");
  }

  /* ======================================================================
     Highlight ring
  ====================================================================== */

  function drawHighlight(d, layer) {
    layer.selectAll("*").remove();

    const rBase = d._lineScore != null ? 10 + 20 * d._lineScore : 20;

    layer.append("circle")
      .datum(d)
      .attr("cx", d.x)
      .attr("cy", d.y)
      .attr("r", rBase)
      .attr("fill", "none")
      .attr("stroke", "#FFD166")
      .attr("stroke-width", 4)
      .attr("pointer-events", "none")
      .attr("opacity", 0.95);
  }

  function anchorHighlight(layer) {
    const ring = layer.select("circle");
    if (ring.empty()) return;
    const d = ring.datum();
    ring.attr("cx", d.x).attr("cy", d.y);
  }

  /* ======================================================================
     Legacy navigation (optional)
  ====================================================================== */

  function handleNodeClick(d) {
    const file = resolveFile(d);
    if (!file) {
      console.info("No resolvable file for node:", d);
      return;
    }

    const base = window.CMS_TOOLS_BASE || "/cms/_tools";
    const highlightId = encodeURIComponent(d.id);

    const url = `${base}/viewD3CodeNodes?file=${encodeURIComponent(file)}&highlight=${highlightId}`;
    window.location.href = url;
  }

  function resolveFile(d) {
    const normalize = (p) => (p ? p.replace(/\\/g, "/") : null);

    if (d?.file) return normalize(d.file);
    if (typeof d?.id !== "string") return null;

    const id = normalize(d.id);
    if (!id) return null;

    const lower = id.toLowerCase();

    const looksLikeFile =
      /\.php$/.test(lower) ||
      lower.includes("app/") ||
      lower.includes("cms/") ||
      lower.includes("public/") ||
      lower.includes("modules/") ||
      lower.includes("config/") ||
      lower.includes("core/");

    return looksLikeFile ? id : null;
  }

  /* ======================================================================
     Dev-time assertions
  ====================================================================== */

  function assertGlobals() {
    const missing = [];

    if (!window.CodeGraphData?.normalize) missing.push("CodeGraphData.normalize");
    if (!window.CodeGraphInteractions?.attachNodeInteractions) missing.push("CodeGraphInteractions.attachNodeInteractions");
    if (!window.CodeGraphHulls?.renderTypeHulls) missing.push("CodeGraphHulls.renderTypeHulls");
    if (!window.CodeGraphUI?.buildGraphDiagnosticsPanel) missing.push("CodeGraphUI.buildGraphDiagnosticsPanel");
    if (!window.CodeGraphUI?.setupGraphFilters) missing.push("CodeGraphUI.setupGraphFilters");
    if (!window.CodeGraphUI?.buildGraphLegend) missing.push("CodeGraphUI.buildGraphLegend");
    if (!window.CodeGraphUI?.escapeHtml) missing.push("CodeGraphUI.escapeHtml");

    if (missing.length) {
      console.warn(
        "d3_codeStructure.js missing required globals. Check script load order:\n- " +
        missing.join("\n- ")
      );
    }
  }
})();